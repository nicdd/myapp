<link rel="import" href="../../bower_components/polymer/polymer-element.html">
<link rel="import" href="../../bower_components/paper-progress-button/paper-progress-button.html">
<link rel="import" href="../../bower_components/granite-file-reader/granite-file-reader.html">
<link rel="import" href="../utils/grt-dropdown-input.html">
<link rel="import" href="../clients/firstclient.html">
<link rel="import" href="../clients/basicclient.html">
<link rel="import" href="../first-domain-styles.html">
<!-- <script src="../../bower_components/webcomponentsjs/webcomponents-lite.js"></script> -->

<dom-module id="import-paechter">
  <template>
    <style include="first-domain-styles">
      :host {
        /* Stretch this element to fill viewport */
        height: 85vh;
        /* Make a flex column layout of children */
        display: flex;
        flex-direction: column;
      }

      .clickHere {
        border-radius: 3px;
        background-color: var(--app-primary-color);
        color: white;
        padding: 0.5rem 1rem;
      }

      .page {
        /* Stretch this element in the parent flex */
        flex: 1;
        /* Make a flex column layout of children */
        display: flex;
        flex-direction: column;
        /*
            Let the page contents scroll. Unnecessary for <vaadin-grid>,
            but could be useful for other pages.
          */
        overflow: auto;
        -webkit-overflow-scrolling: touch;
        padding: 3rem;
      }

      .metacol {
        width: 7rem;
        text-align: center;
      }

      .contentcol {
        text-align: start;
      }
    </style>

    <first-client id="firstclient"></first-client>
    <basic-client id="bclient"></basic-client>
    <div class="toolbar layout horizontal center-justified" flex>
      <paper-progress-button bottom raised on-click="_importRemotePaechterPressed" loading-label="Nicht so hecktisch ..."
        loading="[[_loading]]">Pächter-Daten aus CSV-Datei vom Server importieren <iron-icon icon="add-circle-outline"
          slot="item-icon"></iron-icon>
      </paper-progress-button>
      <granite-file-reader read-as="dataURL" accept=".csv" on-file-read="_doOnFileRead">
        <div class="clickHere">Pächter-Daten aus lokaler CSV-Datei importieren</div>
      </granite-file-reader>
    </div>
    <template is="dom-if" if="[[generalConf.length]]">
      <div class="page">
        <table>
          <thead>
            <th class="metacol">#</th>
            <th class="contentcol">Spaltenname</th>
            <th class="contentcol" title="Die Entsprechung in der zu importierenden Pächtertabelle">Entsprechung
              Pächtertabelle</th>
          </thead>
          <tbody>
            <template is="dom-repeat" items="[[generalConf]]">
              <tr>
                <td class="metacol">
                  [[getOrdnungsnummer(index)]]
                </td>
                <td class="contentcol">
                  <paper-input id="cnm[[index]]" value="[[item.colname]]" readonly></paper-input>
                </td>
                <td class="contentcol">
                  <grt-dropdown-input id="ctp[[index]]" items="[[secondColumns]]" selected="{{entPaars.index.right}}"
                    on-iron-select="_doOnSelect"></grt-dropdown-input>
                </td>

              </tr>
            </template>

          </tbody>
        </table>

      </div>
      <paper-button disabled="[[formInvalid]]" on-click="_mergeImportedAndSave">Weiter</paper-button>
    </template>
  </template>

  <script>
    class ImportPaechter extends Polymer.Element {
      static get is() { return 'import-paechter'; }

      static get properties() {
        return {

          _loading: {
            type: Boolean,
            value: false
          },

          mvdata: {
            type: Array,
            value: [],
            notify: true,
            reflectToAttribute: true
          },

          mfile: {
            type: Object,
            value: null,
            notify: true,
            observer: '_transformCSVToArray'
          },

          secondColumns: {
            type: Array,
            value: null
          },

          entPaars: {
            type: Object,
            value: [],
            notify: true,
            reflectToAttribute: true
          },

          dataAndColumns: {
            type: Object,
            value: null
          },

          generalConf: {
            type: Array,
            value: null,
            notify: true
          },

          formInvalid: {
            type: Boolean,
            notify: true
          },

          completed: {
            type: Boolean,
            value: false,
            notify: true
          }
        }
      }

      ready() {
        super.ready();
        this.$.firstclient.getPaechterAsJSON().then((paechter) => {
          if (paechter && paechter.columns && paechter.columns.length && paechter.data && paechter.data.length) {
            this.set('completed', true)
          }
        }).catch(() => {
          this.set('completed', false)
        })
      }

      _doOnFileRead(e) {
        let self = this;
        let b64Result = e.detail;
        self._urltoFile(b64Result, 'paechter.csv', 'text/csv').then((file) => {
          let reader = new FileReader();
          reader.onload = function (e) {
            let text = reader.result;
            self.set('mfile', text);
          }
          reader.readAsText(file, 'base64');
        })
      }

      _urltoFile(url, filename, mimeType) {
        let self = this;
        return (fetch(url)
          .then(function (res) { return res.arrayBuffer(); })
          .then(function (buf) { return new File([buf], filename, { type: mimeType }); })
          .catch((err) => {
            showToast(self, 'Fehler bei der Importierung der Pächter-Daten aus der lokalen Datei', TOAST_TYPE.ERROR);
          })
        );
      }

      mapToJSON(resp) {
        let usr = document.querySelector('my-app').getAttribute('user')
        usr = JSON.parse(usr);

        let transformedResult = [];
        let columns = resp[0];

        for (let i = 1; i < resp.length; i++) {
          if (resp[i][0] !== 'Ende der Liste') {
            let myRowObj = {};

            for (let j = 0; j < columns.length; j++) {
              let attrName = columns[j];
              let attrValue = (attrName === "GBV" || attrName === "FED" || attrName === "Beitrag" || attrName === "UV" || attrName === "HöV") ? (isFinite(resp[i][j]) && !isNaN(resp[i][j]) ? (parseInt(resp[i][j]) || 0) : 0) : resp[i][j];
              myRowObj[attrName] = attrValue;
            }
            myRowObj['created'] = { user: usr.name, datum: moment().format('YYYYMMDD_HHmm'), source: 'csv' };
            transformedResult.push(myRowObj);
          } else {
            break;
          }

        }
        this.set('columnNames', columns);
        this.set('mvdata', transformedResult);
      }

      _transformCSVToArray() {
        let finalArray = [];
        if (this.mfile) {
          let firstArr = this.mfile.split('\n');
          let secondArray = null;
          firstArr.forEach((el) => {
            secondArray = el.split(',');
            finalArray.push(secondArray);
          })
          this._importLocalPaechterPressed(finalArray);
        }
        
      }

      _importRemotePaechterPressed() {
        this.$.firstclient.getPaechterCSV().then((resp) => {
          if (resp) {
            this.mapToJSON(resp);
            let dataAndColumns = { data: this.mvdata, columns: this.columnNames }
            this.set('dataAndColumns', dataAndColumns)
            let secondColumns = JSON.parse(JSON.stringify(dataAndColumns.columns));
            secondColumns.unshift('**Keine**');
            this.set('secondColumns', secondColumns);
            showToast(this, 'Die Pächter-Daten wurden erfolgreich vom Server geladen. Damit diese auch dauerhaft importiert werden können, setzen Sie die Konfiguration durch die Zuordnung der Tabellenspalten fort.', TOAST_TYPE.WARN, 'center');
          } else {
            showToast(this, 'Bei der Importierung der Vereinsdaten wurden keine Paechterdaten gefunden', TOAST_TYPE.ERROR);
          }
        }).then(() => {
          return this.$.bclient.getGeneralColumnConfig().then((generalConf) => {
            if (generalConf && Array.isArray(generalConf)) {
              this.set('generalConf', generalConf);
            }
          }).then(() => {
            this.validate();
          })
        }).catch((err) => {
          showToast(this, 'Fehler bei der Importierung der Pächter-Daten vom Server', TOAST_TYPE.ERROR);
        })
      }

      saveToDB(dataAndColumns) {
        return this.$.firstclient.postPaechterAsJSON(dataAndColumns);
      }

      _importLocalPaechterPressed(localPaechterFromCSVAsArray) {
        this.$.bclient.getGeneralColumnConfig().then((generalConf) => {
          if (generalConf && Array.isArray(generalConf) && localPaechterFromCSVAsArray && localPaechterFromCSVAsArray.length) {
            this.set('generalConf', generalConf);
            this.mapToJSON(localPaechterFromCSVAsArray);
            let dataAndColumns = { data: this.mvdata, columns: this.columnNames }
            this.set('dataAndColumns', dataAndColumns);
            let secondColumns = JSON.parse(JSON.stringify(dataAndColumns.columns));
            secondColumns.unshift('**Keine**');
            this.set('secondColumns', secondColumns);
            showToast(this, 'Die Pächter-Daten wurden aus der lokalen Datei erfolgreich geladen. Damit diese auch dauerhaft importiert werden können, setzen Sie die Konfiguration durch die Zuordnung der Tabellenspalten fort.', TOAST_TYPE.WARN, 'center');
          } else {
            showToast(this, 'Bei der Importierung der Vereinsdaten wurden keine Paechterdaten gefunden', TOAST_TYPE.ERROR);
          }
        }).then(() => {
          this.validate();
        })
      }

      _setLoading(val) {
        this.set('_loading', val);
      }

      getOrdnungsnummer(index) {
        return index + 1;
      }

      _doOnSelect(e) {
        let self = this;
        if (e && e.target) {
          let myelemId = e.target.id;
          let realIndex = myelemId.substring(3);
          let wertLinks = self.generalConf[realIndex].colname;
          let wertRechts = e.target.selected;
          let path = 'entPaars.' + realIndex;
          let bereitsBelegt = self.entPaars.some((elem) => (elem.right === wertRechts) && (wertRechts !== self.secondColumns[0]));
          if (bereitsBelegt) {
            self.splice('entPaars', realIndex, 1, { left: wertLinks, right: null });
            let thehashid = '#' + myelemId;
            let melem = self.shadowRoot.querySelector(thehashid);
            melem.resetItem(true);
            melem.selected = null;
            melem.errorMessage = "Spaltenname bereits zugeordnet"
          } else {
            self.set(path, { left: wertLinks, right: wertRechts });
          }
        }
        this.validate();
      }

      validate(e) {
        let invalidFound = true;
        if (this.entPaars && this.entPaars.length === this.generalConf.length) {
          invalidFound = this.entPaars.some((elem) => {
            return (!elem.right || !elem.right.length)
          })
        }
        this.set('formInvalid', invalidFound);
      }

      _mergeImportedAndSave() {
        let columns = [];
        this.generalConf.forEach((col) => {
          columns.push(col.alias);
        })
        let data = JSON.parse(JSON.stringify(this.dataAndColumns.data));
        let newData = [];
        data.forEach((paechterData) => {
          let newPaechter = new Paechter(this.entPaars);
          Object.keys(paechterData).forEach((key) => {
            let correspondingPaar = this.entPaars.find((p) => p.right === key);
            if (correspondingPaar) {
              newPaechter[correspondingPaar.left] = paechterData[key];
            }
          })
          newData.push(newPaechter);
        })
        let newDataAndColumns = { data: newData, columns: columns }
        this.saveToDB(newDataAndColumns).then(() => {
          showToast(this, 'Sie haben die Pächter-Daten erfolgreich importiert.', TOAST_TYPE.SUCCESS);
          this.set('completed', true)
        }).catch(() => {
          this.set('completed', false)
          showToast(this, 'Fehler bei der Übertragung der importierten Pächter-Daten in die Datenbank.', TOAST_TYPE.ERROR);
        })

      }

    }

    class Paechter {
      constructor(paechterKeys) {
        if (paechterKeys) {
          this._createEmptyPaechter(paechterKeys)
        }
      }

      _createEmptyPaechter(paechterKeys) {
        paechterKeys.forEach((paar) => {
          this[paar.left] = null;
        })
      }

    }

    window.customElements.define(ImportPaechter.is, ImportPaechter);
  </script>
</dom-module>