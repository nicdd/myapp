<!--
Beschreibung:

Ein Import-Vorgang bedeutet neben der Datenimportierung aus einer CSV-Tabelle auch das Konfigurieren
der Tabellenspalten.

Vor der Durchführung eines Import-Vorgangs gibt es die folgenden möglichen Ausgangssituationen:

1. - es existiert keine Spaltenkonfiguration und keine Daten für den entsprechenden Bereich (Domäne);
2. - es existiert eine Spaltenkonfiguration aber keine Daten;
3. - es existiert keine Spaltenkonfiguration aber die Daten existieren bereits;
4. - sowohl die Spaltenkonfiguration als auch die Daten sind vorhanden.

In der Auganssituation 1:

Der Benutzer sieht zuerst die Domänenname und den Button "Lokale CSV-Datei importieren".
Nach der Betätigung des Buttons bzw. Importierung der Daten, wird dem Benutzer die Maske zur 
Konfigurierung der Tabellenspalten, wobei die Auswahlmöglichkeiten in der Auswahlbox "Entsprechung"
die aus den Spaltennamen der CSV-Datei bestehen. Dies sichert eine richtige Zurdnung zwischen den 
importierten und später dargestellten Daten.
Nach der Vervollständigung der Konfiguration, werden die Daten und die Spaltenkonfiguration gespeichert.

In der Auganssituation 2:

Die vorhandene Spaltenkonfiguration wird noch nicht angezeigt. Der Benutzer muss wie in der Ausganssituation 1
Daten importieren. Danach wird ihm die vorhandene Spaltenkonfiguration angezeigt, er kann diese bearbeiten. 

In der Auganssituation 3:

Die Felder der Maske für die Spaltenkonfiguration werden angezeigt, diese werden am Anfang allerdings
nur mit in den technischen Spaltennamen automatisch vervollständigt. Die restlichen Eingaben werden
durch den Benutzer vorgenommen und anschließend gespeichert.  

In der Auganssituation 4:

Hier könnte die Intention des Benutzers sein, entweder 
  a. die vorhandenen Daten mit neuen Daten zu überschreiben, oder 
  b. nur die vorhandene Konfiguration zu bearbeiten.

  Per Radiobuttons enscheidet er sich für eine dieser 2 Optionen.

  Im Falle von "a" wird er in der Ausgangssituation 2 versetzt.
  
  Im Falle von "b" wird die Spaltenkonfiguration ohne den Tabellenkopf "Entsprechung" angezeigt.
  Das Ergebnis der Bearbeitung der Spaltenkonfiguration, darf nicht zur Inkonsistenz zwischen
  der am Ende der Bearbeitung zu speichernden Spaltenkonf. und den vorhandenen Daten. 
  Aus diesem Grund wird der Benutzer:
  
  b1 - keine der vorhandenen Spalten entfernen dürfen;
  b3 - an einer vorhandenen Spalte die Optionen "Spaltenname" und "Datentyp" nicht verändern dürfen;
  b2 - an einer vorhandenen Spalte nur die Optionen "Anzeigen", "Gruppe und Gruppenposition",
       "Alias" sowie die Rollen-Checkboxen verändern dürfen;
  b3 - neue Gruppe/-n hinzufügen oder vorhandene löschen;
  b4 - neue Spalte hinzufügen, wobei die Eintragung in "Spaltenname" nicht bereits vorhanden ist. 

-->


<link rel="import" href="../../bower_components/polymer/polymer-element.html">
<link rel="import" href="../../bower_components/paper-progress-button/paper-progress-button.html">
<link rel="import" href="../../bower_components/paper-input/paper-input.html">
<link rel="import" href="../../bower_components/paper-checkbox/paper-checkbox.html">
<link rel="import" href="../../bower_components/granite-file-reader/granite-file-reader.html">
<link rel="import" href="../utils/grt-dropdown-input.html">
<link rel="import" href="../clients/firstclient.html">
<link rel="import" href="../clients/basicclient.html">
<link rel="import" href="../first-domain-styles.html">
<link rel="import" href="../table-styles.html">
<link rel="import" href="../shared-styles.html">

<dom-module id="import-allgemein">
  <template>
    <style include="first-domain-styles table-styles shared-styles">
      :host {
        /* Stretch this element to fill viewport */
        /*height: 85vh;
        /* Make a flex column layout of children */
        display: flex;
        flex-direction: column;

        --paper-input-error: {
          white-space: normal;
        }


      }

      .clickHere {
        border-radius: 3px;
        background-color: var(--app-primary-color);
        color: white;
        padding: 0.5rem 1rem;
      }

      .page {
        /* Stretch this element in the parent flex */
        flex: 1;
        /* Make a flex column layout of children */
        display: flex;
        flex-direction: column;
        -webkit-overflow-scrolling: touch;
        padding: 1rem 0.2rem;
      }

      .metacol {
        width: 1rem;
        text-align: center;
      }

      /* .contentcol {
        text-align: start;
      } */
      .contentcol {
        text-align: center;
        padding-left: 0.7rem;
      }

      .labelbutton {
        padding: 3px 3px;
      }

      .labelbutton div {
        display: inline-block;
      }

      paper-input.posinput {
        max-width: 80px !important;
      }

      paper-input.gosinput {
        max-width: 50px !important;
      }

      .cardtitle {
        padding: 0px 16px 16px 16px;
      }
    </style>

    <first-client id="firstclient"></first-client>
    <basic-client id="bclient"></basic-client>
    <div class="toolbar layout horizontal center-justified" flex>
      <paper-input id="domname" always-float-label minlength="1" maxlength="100" allowed-pattern="^[a-zA-Z0-9]$"
        required auto-validate label="Domänenname" error-message="Pflichteingabe - nur Kleinbuchstaben"
        on-input="_validateForSNameAliasEntsprechung" value="{{domainname}}" disabled="[[disableDomainNameInput]]">
      </paper-input>
      <granite-file-reader disabled="[[domainname.length]]" read-as="dataURL" accept=".csv"
        on-file-read="_doOnFileRead">
        <div class="clickHere">Lokale CSV-Datei importieren</div>
      </granite-file-reader>
    </div>
    <template is="dom-if" if="[[spaltenConf]]">
      <div class="layout vertical card no_side_margins">
        <div class="mcard layout vertical">
          <b class="cardtitle">
            Spalten und Spaltengruppen
          </b>
          <div class="layout horizontal">
            <div class="layout horizontal" style="min-width: 70vh;">
              <div class="cardcontent layout horizontal">
                <paper-input class="labelgroup" min="1" max="100" always-float-label label="Anzahl der Spalten"
                  type="number" required value="{{tempAnzahlSpalten}}"></paper-input>
                <paper-button bottom raised
                  disabled="[[_isUebernehmenDisabled(tempAnzahlSpalten, spaltenConf.columns.length)]]"
                  on-click="_addReduceColumns">[[_getUebernehmenButtonName(tempAnzahlSpalten,
                  spaltenConf.columns.length)]]
                </paper-button>
              </div>

              <div class="layout horizontal">
                <paper-input class="labelgroup" always-float-label label="Neue Spaltengruppe" value="{{lastNewGroup}}">
                </paper-input>
                <paper-button bottom raised disabled="[[!lastNewGroup]]" on-click="_addNewColumnGroup">hinzufügen
                </paper-button>
              </div>
            </div>

            <div class="cardcontent">
              <template is="dom-repeat" items="[[spaltenConf.column_groups]]">
                <button class="labelbutton" title="Zum Löschen auf Icon drucken">
                  <div>
                    <div>[[item]]</div>
                    <iron-icon title="Gruppe entfernen" id="rmg[[index]]" icon="remove-circle-outline" slot="item-icon"
                      on-click="_removeGroup"></iron-icon>
                  </div>
                </button>
              </template>
            </div>
          </div>

        </div>

        <div class="page">
          <table>
            <thead>
              <th class="metacol">#</th>
              <th class="contentcol" colspan="2"
                title="Sollen die Daten aus dieser Spalte im Tabellenkopf angezeigt werden? An welcher Stelle?">Anzeigen
              </th>
              <th class="contentcol" colspan="2"
                title="In welcher Spaltengruppe wird diese Spalte eingeteilt und an welcher Stelle?">Gruppe und
                Gruppenposition</th>
              <th class="contentcol" title="Technischer Spaltenname für die Datenbanktabelle">Spaltenname</th>
              <th class="contentcol" title="Erforderlicher Hinweis für die technische Verarbeitung">Datentyp</th>
              <th class="contentcol" title="So wird diese Spalte in der Maske aussehen">Alias</th>
              <template is="dom-if" if="[[secondColumns.length]]">
                <th class="contentcol" title="Die Entsprechung in der zu importierenden Tabelle">Entsprechung
                  Import</th>
              </template>
              <th class="contentcol" title="Darf für den Pächter-Bereich verfügbar sein">Pächter</th>
              <th class="contentcol" title="Darf für den Versicherungs-Bereich verfügbar sein">Versicherung</th>
              <th class="contentcol" title="Darf für den FM-Bereich verfügbar sein">F-Mitglieder</th>
              <th class="contentcol" title="Spaltenname entfernen">Löschen</th>
            </thead>
            <tbody>
              <template is="dom-repeat" items="[[spaltenConf.columns]]">
                <tr>
                  <td class="metacol">
                    [[_getOrdnungsnummer(index)]]
                  </td>
                  <td class="contentcol">
                    <paper-checkbox id="shw[[index]]" checked="{{item.th_show}}" on-change="_doOnCbChecked">
                    </paper-checkbox>
                  </td>
                  <td class="contentcol">
                    <paper-input id="pos[[index]]" class="posinput" value="{{item.position}}" auto-validate
                      required$="[[item.th_show]]" disabled="[[!item.th_show]]" on-input="_setPattern"
                      maxlength="[[_getMaxLength(item.position, spaltenConf.columns.length)]]"
                      error-message="mehrmals oder leer">
                    </paper-input>
                  </td>
                  <td class="contentcol">
                    <grt-dropdown-input id="ctg[[index]]" class="gosdd" items="[[spaltenConf.column_groups]]"
                      selected="{{item.gruppe}}" on-iron-select="_doOnSelectGruppe" required
                      error-message="Spaltengruppe darf nicht leer sein">
                    </grt-dropdown-input>
                  </td>
                  <td class="contentcol">
                    <paper-input id="gos[[index]]" class="gosinput" value="{{item.gruppen_position}}" auto-validate
                      required="[[item.gruppe.length]]" disabled="[[!item.gruppe.length]]" on-input="_setPattern"
                      minlength="1"
                      maxlength="[[_getMaxLengthGroupPos(index, item.gruppen_position, item.gruppe, spaltenConf.column_groups.length)]]"
                      error-message="Einmaliges Pflichtfeld">
                    </paper-input>
                  </td>

                  <td class="contentcol">
                    <paper-input id="cnm[[index]]" on-input="_validateForSNameAliasEntsprechung"
                      value="{{item.colname}}" auto-validate allowed-pattern="^[A-Z0-9_]$" required
                      error-message="Das Feld muss einen durch- und großgeschriebenen technischen Spaltennamen enthalten">
                    </paper-input>
                  </td>
                  <td class="contentcol">
                    <grt-dropdown-input id="ctp[[index]]"
                      items='["number","numberstring","string","longstring","object","boolean", "date"]' required
                      selected="{{item.coltype}}" on-iron-select="validate" error-message="Eingabe erfolrderlich">
                    </grt-dropdown-input>
                  </td>
                  <td class="contentcol">
                    <paper-input id="als[[index]]" on-input="_validateForSNameAliasEntsprechung" value="{{item.alias}}"
                      auto-validate allowed-pattern="^[a-zA-Z0-9 äöüß-]$" required
                      error-message="Das Feld muss einen Spaltennamen enthalten"></paper-input>
                  </td>
                  <template is="dom-if" if="[[secondColumns.length]]">
                    <td class="contentcol">
                      <grt-dropdown-input id="ctp[[index]]" items="[[secondColumns]]"
                        selected="{{entPaars.index.right}}" on-iron-select="_doOnSelect" required
                        error-message="Pflichtauswahl oder **Keine**">
                      </grt-dropdown-input>
                    </td>
                  </template>
                  <td class="contentcol">
                    <paper-checkbox id="cbp[[index]]" checked="[[_hasRole('paechter', item)]]"
                      on-change="_doOnCbChecked" disabled="[[_isCBDisabled('paechter')]]">
                    </paper-checkbox>
                  </td>
                  <td class="contentcol">
                    <paper-checkbox id="cbv[[index]]" checked="[[_hasRole('versicherung', item)]]"
                      on-change="_doOnCbChecked" disabled="[[_isCBDisabled('versicherte')]]"></paper-checkbox>

                  </td>
                  <td class="contentcol">
                    <paper-checkbox id="cbf[[index]]" checked="[[_hasRole('foerdermitglieder', item)]]"
                      on-change="_doOnCbChecked" disabled="[[_isCBDisabled('foerdermitglieder')]]"></paper-checkbox>

                  </td>
                  <td class="metacol">
                    <button id="dlb[[index]]" on-click="_removeColumn" class="first-domain-endpagebutton action-button">
                      <iron-icon id="dli[[index]]" icon="delete" slot="item-icon" on-click="_removeColumn"></iron-icon>
                    </button>
                  </td>

                </tr>
              </template>

            </tbody>
          </table>
        </div>
        <paper-button on-click="_mergeImportedAndSave">
          [[_getText(spaltenConf.*, dataAndColumns.*)]]</paper-button>
      </div>
    </template>

  </template>

  <script>
    class ImportAllgemein extends Polymer.Element {
      static get is() { return 'import-allgemein'; }

      static get properties() {
        return {

          selected: {
            type: Boolean,
            observer: "_selectedChanged"
          },

          domainname: {
            type: String,
          },

          disableDomainNameInput: {
            type: Boolean,
          },

          tempAnzahlSpalten: {
            type: Number,
            value: null,
            notify: true
          },

          tabledata: {
            type: Array,
            value: [],
            notify: true,
            reflectToAttribute: true
          },

          mfile: {
            type: Object,
            value: null,
            notify: true,
            observer: '_transformCSVToArray'
          },

          secondColumns: {
            type: Array,
            value: null
          },

          entPaars: {
            type: Object,
            value: [],
            notify: true,
            reflectToAttribute: true
          },

          dataAndColumns: {
            type: Object,
            value: null
          },

          spaltenConf: {
            type: Object,
            value: null,
            notify: true
          },

          formInvalid: {
            type: Boolean,
            notify: true
          },

          anzeigeOptsInvalid: {
            type: Boolean,
            notify: true
          },

          completed: {
            type: Boolean,
            value: false,
            notify: true
          },

          _defaultColumnConf: {
            type: Object,
            value: { column_groups: [], columns: [{ "colname": "GARTENNUMMER", "coltype": "string", "alias": "GNr", "rolen": ["paechter", "versicherung"] }, { "colname": "ANREDE", "coltype": "string", "alias": "Anrede", "rolen": ["paechter", "versicherung"] }, { "colname": "NACHNAME", "coltype": "string", "alias": "Nachname", "rolen": ["paechter", "versicherung"] }, { "colname": "VORNAME", "coltype": "string", "alias": "Vorname", "rolen": ["paechter", "versicherung"] }, { "colname": "STRASSE", "coltype": "string", "alias": "Strasse", "rolen": ["paechter", "versicherung"] }, { "colname": "PLZ", "coltype": "string", "alias": "PLZ", "rolen": ["paechter", "versicherung"] }, { "colname": "WOHNORT", "coltype": "string", "alias": "Wohnort", "rolen": ["paechter", "versicherung"] }, { "colname": "TELEFON", "coltype": "string", "alias": "Telefon", "rolen": ["paechter", "versicherung"] }, { "colname": "WEG", "coltype": "string", "alias": "Weg", "rolen": ["paechter", "versicherung"] }, { "colname": "FLAECHE", "coltype": "string", "alias": "Fläche", "rolen": ["paechter", "versicherung"] }, { "colname": "GEBURTSDATUM", "coltype": "string", "alias": "Geburtsdatum", "rolen": ["paechter"] }, { "colname": "EMAIL", "coltype": "string", "alias": "E-Mail", "rolen": ["paechter", "versicherung"] }, { "colname": "BEMERKUNGEN", "coltype": "string", "alias": "Bemerkung (P)", "rolen": ["paechter"] }, { "colname": "V_BEMERKUNG", "coltype": "string", "alias": "Bemerkung (V)", "rolen": ["versicherung"] }, { "colname": "GBV", "coltype": "number", "alias": "GBV", "rolen": ["versicherung"] }, { "colname": "FED", "coltype": "number", "alias": "FED", "rolen": ["versicherung"] }, { "colname": "HOEV", "coltype": "number", "alias": "HöV", "rolen": ["versicherung"] }, { "colname": "A7_1", "coltype": "number", "alias": "Solar", "rolen": ["versicherung"] }, { "colname": "A7_3", "coltype": "string", "alias": "SA", "rolen": ["versicherung"] }, { "colname": "A7_4", "coltype": "number", "alias": "GS", "rolen": ["versicherung"] }, { "colname": "UV", "coltype": "number", "alias": "Unfall", "rolen": ["versicherung"] }, { "colname": "BEITRAG", "coltype": "number", "alias": "Beitrag", "rolen": ["versicherung"] }] }
          },

          lastNewGroup: {
            type: String,
          }
        }
      }

      static get observers() {
        return ['_bothValidations(spaltenConf.columns.length, entPaars.length)'];
      }

      _selectedChanged(newV, oldV) {
        if (newV) {
          this._tryThisColumnConfig().then((conf) => {
            if (conf && conf.columns && Array.isArray(conf.columns)) {
              conf.columns = this._checkForMustColumns(conf.columns);
              let anzC = conf.columns.length;
              this.set('tempAnzahlSpalten', anzC)
              this.set('spaltenConf', conf);
            }
          })
        }
      }

      _addNewColumnGroup() {
        if (this.lastNewGroup && !this.spaltenConf.column_groups.some((elem) => elem === this.lastNewGroup)) {
          this.push('spaltenConf.column_groups', this.lastNewGroup);
          this.set('lastNewGroup', null);
        }
      }

      _removeGroup(e) {
        if (e && e.target && e.target.id) {
          let idx = e.target.id.substring(3);
          let grLabel = this.spaltenConf.column_groups[idx];

          this.splice('spaltenConf.column_groups', idx, 1);
          this.spaltenConf.columns.forEach((col, colIdx) => {
            if (col.gruppe === grLabel) {
              this.set('spaltenConf.columns.' + colIdx + '.gruppe', null);
              this.set('spaltenConf.columns.' + colIdx + '.gruppen_position', null);
            }
          })
        }
      }

      // Laden
      _doOnFileRead(e) {
        let self = this;
        let b64Result = e.detail;
        self._urltoFile(b64Result, (self.domainname + '.csv'), 'text/csv').then((file) => {
          let reader = new FileReader();
          reader.onload = function (e) {
            let text = reader.result;
            self.set('mfile', text);
          }
          reader.readAsText(file, 'base64');
        })
      }

      _urltoFile(url, filename, mimeType) {
        let self = this;
        return (fetch(url)
          .then(function (res) { return res.arrayBuffer(); })
          .then(function (buf) { return new File([buf], filename, { type: mimeType }); })
          .catch((err) => {
            showToast(self, 'Fehler bei der Importierung der Daten aus der lokalen Datei', TOAST_TYPE.ERROR);
          })
        );
      }

      _transformCSVToArray() {
        let finalArray = [];
        if (this.mfile) {
          let firstArr = this.mfile.split('\n');
          if (Array.isArray(firstArr) && firstArr.length > 0 && !firstArr[firstArr.length - 1].length) {
            firstArr.pop();
          }
          let secondArray = null;
          firstArr.forEach((el, zIdx) => {
            secondArray = el.split(',');
            let thirdArray = [];
            for (let i = 0; i < secondArray.length; i++) {
              if (secondArray[i].startsWith('"') && !(secondArray[i].length > 1 && secondArray[i].endsWith('"'))) {
                let indexOfLastFalsyKomaSplited = null;
                let k = i + 1;
                while (!indexOfLastFalsyKomaSplited && k < secondArray.length) {
                  if (secondArray[k].endsWith('"') && !(secondArray[k].length > 1 && secondArray[k].startsWith('"'))) {
                    indexOfLastFalsyKomaSplited = k;
                  }
                  k++;
                }
                // Eine Zelle mit schliessendem Komma gefunden
                if (indexOfLastFalsyKomaSplited) {
                  let newZelle = secondArray[i].substring(1);
                  while (i < indexOfLastFalsyKomaSplited) {
                    i++;
                    if (i === indexOfLastFalsyKomaSplited) {
                      //entferne das " an Ende des Strings, das ist die letzte Zelle die 
                      // zum ursprünglichen Inhalt gehört
                      newZelle += secondArray[i].substring(0, secondArray[i].length - 1);
                    } else {
                      // noch nicht die letzte Zelle die 
                      // zum ursprünglichen Inhalt gehört
                      newZelle += secondArray[i];
                    }
                  }
                  thirdArray.push(newZelle);
                } else {
                  thirdArray.push(secondArray[i]);
                }
              } else {
                thirdArray.push(secondArray[i]);
              }
            }
            finalArray.push(thirdArray);
          })

          this._importLocalMemberPressed(finalArray);
        }
      }

      _tryThisColumnConfig() {
        return this.$.bclient.getDomaenenColumnConfig(this.domainname).then((domConf) => {
          showToast(this, 'Die domänenspezifische Spaltenkonfiguration wurde erfolgreich geladen', TOAST_TYPE.SUCCESS);
          return domConf;
        }).catch((err) => {
          showToast(this, 'Die domänenspezifische Spaltenkonfiguration konnte nicht geladen werden, die allgemeine Spaltenkofiguration wird benutzt', TOAST_TYPE.WARN);
          return this.$.bclient.getDomaenenColumnConfig('general').then((generalConf) => {
            if (Array.isArray(generalConf)) {
              return { "columns": generalConf, "column_groups": [] }
            } else return generalConf;
          }).catch((err) => {
            showToast(this, 'Keine Spaltenkonfigurationnn konnte geladen werden. Default wird benutzt.', TOAST_TYPE.WARN);
            return this._defaultColumnConf;
          })
        })
      }

      _importLocalMemberPressed(localMemberFromCSVAsArray) {
        this._tryThisColumnConfig().then((domConf) => {
          if (!domConf) {
            showToast(this, 'Keine Spaltenkonfigurationnn konnte geladen werden', TOAST_TYPE.ERROR);
            throw 'nicht gefunden';
          } else {
            this._initData(domConf, localMemberFromCSVAsArray);
          }
          let anzSpElem = this.shadowRoot.getElementById('domname');
          anzSpElem.scrollIntoView({ behavior: "smooth" });

        })
      }

      _initData(conf, csvData) {
        if (conf && conf.columns && Array.isArray(conf.columns) && csvData && csvData.length) {
          conf.columns = this._checkForMustColumns(conf.columns);
          let anzC = conf.columns.length;
          this.set('tempAnzahlSpalten', anzC)
          this.set('spaltenConf', conf);
          this.set('completed', true && !this._isDisabled())
          this.mapToJSON(csvData);
          let dataAndColumns = { data: this.tabledata, columns: this.columnNames }
          this.set('dataAndColumns', dataAndColumns);
          let secondColumns = JSON.parse(JSON.stringify(dataAndColumns.columns));
          secondColumns.unshift('**Keine**');
          this.set('secondColumns', secondColumns);
          showToast(this, 'Die Daten wurden aus der lokalen Datei erfolgreich geladen. Damit diese auch dauerhaft importiert werden können, setzen Sie die Konfiguration durch die Zuordnung der Tabellenspalten fort.', TOAST_TYPE.WARN, 'center');
        } else {
          this.set('_defaultColumnConf', this._checkForMustColumns(this._defaultColumnConf))
          let anzC = this._defaultColumnConf.columns.length;
          this.set('tempAnzahlSpalten', anzC)
          this.set('spaltenConf', this._defaultColumnConf);
          this.set('completed', true && !this._isDisabled())
          showToast(this, 'Bei der Importierung wurden keine Daten für die Domäne ' + this.domainname + ' gefunden', TOAST_TYPE.ERROR);
        }
      }

      _checkForMustColumns(conf) {
        return conf;
      }

      mapToJSON(resp) {
        let usr = document.querySelector('my-app').getAttribute('user')
        usr = JSON.parse(usr);
        let transformedResult = [];
        let columns = resp[0];
        for (let i = 1; i < resp.length; i++) {
          if (resp[i][0] !== 'Ende der Liste') {
            let myRowObj = {};
            for (let j = 0; j < columns.length; j++) {
              let attrName = columns[j];
              let attrValue = (attrName === "GBV" || attrName === "FED" || attrName === "Beitrag" || attrName === "UV" || attrName === "HöV") ? (isFinite(resp[i][j]) && !isNaN(resp[i][j]) ? (parseInt(resp[i][j]) || 0) : 0) : resp[i][j];
              myRowObj[attrName] = attrValue;
            }
            myRowObj['created'] = { user: usr.name, datum: moment().format('YYYYMMDD_HHmm'), source: 'csv' };
            transformedResult.push(myRowObj);
          } else {
            break;
          }
        }
        this.set('columnNames', columns);
        this.set('tabledata', transformedResult);
      }

      // Speichern

      _mergeImportedAndSave() {
        if (!this.dataAndColumns) {
          this._saveSpaltenConfig();
        } else {
          let data = JSON.parse(JSON.stringify(this.dataAndColumns.data));
          let newData = [];
          data.forEach((memberData) => {
            let newMember = new Member(this.entPaars);
            Object.keys(memberData).forEach((key) => {
              let correspondingPaar = this.entPaars.find((p) => p.right === key);
              if (correspondingPaar) {
                newMember[correspondingPaar.left] = memberData[key];
              }
            })
            newMember = this._checkDataForMustContent(newMember);
            newData.push(newMember);
          })
          newData = this._makeUnicIds(newData);
          this.saveToDB(newData).then(() => {
            showToast(this, 'Sie haben die Daten erfolgreich importiert.', TOAST_TYPE.SUCCESS);
            this.set('completed', true)
          }).catch(() => {
            this.set('completed', false)
            showToast(this, 'Fehler bei der Übertragung der importierten Daten in die Datenbank.', TOAST_TYPE.ERROR);
          }).finally(() => {
            this._saveSpaltenConfig();
          })
        }
      }

      _saveSpaltenConfig() {
        this.$.bclient.postDomaenenColumnConfig(this.spaltenConf, this.domainname).then(() => {
          showToast(this, 'Die Konfiguration der Spalten für die Domäne' + this.domainname + 'wurde erfolgreich gespeichert', TOAST_TYPE.SUCCESS);
        }).catch(() => {
          showToast(this, 'Fehler bei der Speicherung der Spaltenkonfiguration für die Domäne ' + this.domainname, TOAST_TYPE.ERROR);
        });
      }

      _checkDataForMustContent(newMember) {
        return newMember;
      }

      _makeUnicIds(newData) {
        return newData;
      }

      saveToDB(dataAndColumns) {
        return this.$.firstclient.postAsJSON(dataAndColumns, this.domainname);
      }

      // Bearbeitungsmethoden
      _addReduceColumns() {
        if (!this.spaltenConf || !this.spaltenConf.columns) {
          this.spaltenConf.columns = [];
        }
        if (this.tempAnzahlSpalten > this.spaltenConf.columns.length) {
          let diff = this.tempAnzahlSpalten - this.spaltenConf.columns.length;
          while (diff) {
            this._addColumn();
            diff--;
          }
        } else if (this.tempAnzahlSpalten < this.spaltenConf.columns.length) {
          let diff = this.spaltenConf.columns.length - this.tempAnzahlSpalten;
          while (diff) {
            this._removeColumn(this.spaltenConf.columns.length - 1);
            diff--;
          }
        }
      }

      _addColumn() {
        this.push('spaltenConf.columns', { colname: null, coltype: null, alias: null, rolen: [] });
      }

      _removeColumn(indexParam) {
        let index = null;
        if ((typeof indexParam === 'number')) {
          index = indexParam;
        } else if (indexParam.target && indexParam.target.id) {
          index = parseInt(indexParam.target.id.substring(3));
          indexParam.preventDefault();
          indexParam.stopPropagation();
        }
        if (index || index === 0) {
          let spToDel = this.spaltenConf.columns[index];
          this.splice('spaltenConf.columns', index, 1)
          if (this.entPaars && this.entPaars[index] && this.entPaars[index].left === spToDel.colname) {
            this.splice('entPaars', index, 1);
          }
        }
        this.set('tempAnzahlSpalten', this.spaltenConf.columns.length);
      }

      _bothValidations() {
        this._validateForSNameAliasEntsprechung();
        this._validateForAnzeigeOptionen();
      }

      _validateForSNameAliasEntsprechung(e) {
        let invalidFound = false;
        if (this.domainname && this.domainname.length && this.entPaars && this.spaltenConf && this.spaltenConf.columns && this.entPaars.length === this.spaltenConf.columns.length) {
          let bothLaenge = this.entPaars.length;
          for (let i = 0; i < bothLaenge; i++) {
            let gCElem = this.spaltenConf.columns[i];
            let invConfFound = (!gCElem.colname || !gCElem.colname.length || !gCElem.coltype || !gCElem.coltype.length || !gCElem.alias || !gCElem.alias.length);
            let entPElem = this.entPaars[i];
            let invEntPFound = (!entPElem || !entPElem.right || !entPElem.right.length);
            invalidFound = invalidFound || invConfFound || invEntPFound;
          }
        } else {
          invalidFound = true;
        }
        this.set('formInvalid', invalidFound);
      }

      _validateForAnzeigeOptionen() {
        let checkBoxFeldDissensFound = false;
        if (this.spaltenConf && this.spaltenConf.columns && Array.isArray(this.spaltenConf.columns)) {
          this.spaltenConf.columns.forEach((spalte, idx) => {
            if (spalte.th_show && (!spalte.position || isNaN(spalte.position))) {
              checkBoxFeldDissensFound = true;
            }
          })
        }
        let pInputs = this.shadowRoot.querySelectorAll('paper-input.posinput');
        pInputs = Array.from(pInputs).filter((el) => {
          return el.invalid === true;
        });
        this.set('anzeigeOptsInvalid', (checkBoxFeldDissensFound || (Array.isArray(pInputs) && pInputs.length > 0)))
      }

      _setPattern(e) {
        //on-focus wird das pattern für das aktuelle element gesetzt
        //on-input wird das pattern für die anderen elemente neu berechnet, denn es könnten manche erlaubt werden
        let keyToSearch;
        if (e.target) {
          let idPrefix = e.target.id.substring(0, 3);
          let idSuffix = parseInt(e.target.id.substring(3));
          let iterateOverData, iterateOverElements;
          if (idPrefix === 'pos') {
            keyToSearch = 'position';
            iterateOverData = this.spaltenConf.columns;
            iterateOverElements = this.shadowRoot.querySelectorAll('.' + idPrefix + 'input')

          } else if (idPrefix === 'gos') {
            let grDD = this.shadowRoot.getElementById(('ctg' + idSuffix));
            let selectedGruppe = grDD.selected;
            keyToSearch = 'gruppen_position';
            iterateOverData = this.spaltenConf.columns.filter((col) => col.gruppe === selectedGruppe);
            iterateOverElements = this.shadowRoot.querySelectorAll('.' + idPrefix + 'input');
            iterateOverElements = Array.from(iterateOverElements).filter((el, idx) => {
              let ddEl = this.shadowRoot.getElementById(('ctg' + idx));
              return ddEl.selected === selectedGruppe;
            })
          }
          if ((e.type === "input")) {
            //   debugger;
            //   id = e.target.id;
            //   this._refreshPatternForIdExceptingIndex(iterateOverData, id, keyToSearch, ignoreIndex);

            // } else if (e.type === "input") {

            iterateOverData.forEach((spalte, ignoreIdx) => {
              //if (idx !== ignoreIndex) {
              this._refreshPatternForIdExceptingIndex(iterateOverData, iterateOverElements, keyToSearch, idPrefix, ignoreIdx);
              // }
            })

          }
          if (idPrefix === 'pos') {
            this._validateForAnzeigeOptionen();
          }

        }
      }

      _refreshPatternForIdExceptingIndex(iterateOverData, iterateOverElements, keyToSearch, idPrefix, ignoreIdx) {
        let patternPrefix = '^(?!(?:';
        let patternSuffix = ')$)[1-9]\\d{0,2}$';
        let blackList = '';
        let mId = idPrefix + ignoreIdx;
        if (iterateOverData && Array.isArray(iterateOverData)) {
          iterateOverData.forEach((spalte, idx) => {
            // setze NICHT den Wert des Aufrufenden Elements in die Pattern-Black-List
            // sonst wäre keine Eingabe mehr erlaubt, sondern nur bei den anderen
            if (idx !== ignoreIdx && !!spalte[keyToSearch]) {
              blackList = blackList + (blackList.length ? "|" : '') + spalte[keyToSearch];
            }
          })
        }
        let pt = (patternPrefix + blackList + patternSuffix)
        iterateOverElements[ignoreIdx].setAttribute("pattern", pt);
        iterateOverElements[ignoreIdx].validate();
      }

      _doOnSelect(e) {
        let self = this;
        if (e && e.target) {
          let myelemId = e.target.id;
          let realIndex = myelemId.substring(3);
          let wertLinks = self.spaltenConf.columns[realIndex].colname;
          let wertRechts = e.target.selected;
          let path = 'entPaars.' + realIndex;

          let bereitsBelegt = self.entPaars.find((elem) => (!!elem) && (elem.right === wertRechts) && (wertRechts !== self.secondColumns[0]));
          if (bereitsBelegt) {
            self.splice('entPaars', realIndex, 1, { zeile: (parseInt(realIndex) + 1), left: wertLinks, right: null });
            let thehashid = '#' + myelemId;
            let melem = self.shadowRoot.querySelector(thehashid);
            melem.resetItem(true);
            melem.selected = null;
            melem.errorMessage = "Spaltenname in Zeile " + bereitsBelegt.zeile + " bereits zugeordnet"
          } else {
            self.set(path, { zeile: (parseInt(realIndex) + 1), left: wertLinks, right: wertRechts });
          }
        }
        this._validateForSNameAliasEntsprechung();
      }

      _doOnSelectGruppe(e) {
        let self = this;
        if (e && e.target) {
          let myelemId = e.target.id;
          let realIndex = myelemId.substring(3);
          let selectedGruppe = e.target.selected;
          let path = 'spaltenConf.columns.' + realIndex + '.gruppe';
          self.set(path, selectedGruppe);
        }
      }

      _doOnCbChecked(e) {
        let idprefix = e.target.id.substring(0, 3);
        let realIndex = e.target.id.substring(3);
        let role = null;
        switch (idprefix) {
          case 'cbp':
            role = 'paechter';
            this._setRollen(e, realIndex, role);
            break;
          case 'cbv':
            role = 'versicherung';
            this._setRollen(e, realIndex, role);
            break;
          case 'cbf':
            role = 'foerdermitglieder';
            this._setRollen(e, realIndex, role);
            break;
          case 'shw':
            this._resetPosition(e, realIndex);
            break;
          default:
            break;
        }
      }

      _setRollen(e, realIndex, role) {
        if (e.currentTarget.checked) {
          let path = "spaltenConf.columns." + realIndex + ".rolen";
          this.push(path, role);
        } else {
          let path = "spaltenConf.columns." + realIndex + ".rolen";
          let rolen = this.get(path);
          let idx = rolen.indexOf(role);
          this.splice(path, idx, 1);
        }
      }

      _resetPosition(e, realIndex) {
        let posElement = this.shadowRoot.getElementById(('pos' + realIndex));
        if (!e.currentTarget.checked) {
          //posElement.value = (this.spaltenConf.length + 1)
          posElement.value = null;
          this._setPattern({ "type": "input", "target": { "id": ('pos' + realIndex) } })
        } else {
          posElement.validate();
        }
        this._validateForAnzeigeOptionen();
      }

      _getOrdnungsnummer(index) {
        return index + 1;
      }

      _hasRole(rolename, item) {
        return item.rolen && Array.isArray(item.rolen) && item.rolen.indexOf(rolename) >= 0;
      }

      _isCBDisabled(cbrolle) {
        return cbrolle !== this.domainname;
      }

      _isDisabled() {
        return (this.formInvalid || this.anzeigeOptsInvalid);
      }

      _getMaxLength(position, sClength) {
        // Trick um die Feldinvalidierung bei Eingaben über die Anzahl der Spalten zu erzwingen
        if (position > sClength) {
          return 0;
        } else {
          let sClengthAsString = '' + sClength;
          return sClengthAsString.length;
        }
      }

      _getMaxLengthGroupPos(idx, position, gruppe) {
        let toReturn = 999;

        let allDDWithThisValue = this.spaltenConf.columns.filter((el) => {
          return el.gruppe === gruppe;
        });

        // Trick um die Feldinvalidierung bei Eingaben über die Anzahl der Spalten zu erzwingen
        if (position > allDDWithThisValue.length || !this.spaltenConf.column_groups.some((gr) => gr === gruppe)) {
          toReturn = 0;
        } else {
          let sClengthAsString = '' + allDDWithThisValue.length;
          toReturn = sClengthAsString.length;
        }
        let gosElem = this.shadowRoot.getElementById(('gos' + idx));
        if (gosElem) {
          gosElem.setAttribute('maxlength', toReturn);
          gosElem.validate();
        }

        return toReturn;
      }

      _getUebernehmenButtonName(tempAnzahlSpalten, anzahlColumns) {
        if (!tempAnzahlSpalten) {
          return "Übernehmen";
        } else {
          if (parseInt(tempAnzahlSpalten) > (parseInt(anzahlColumns) || 0)) {
            return "Erhöhen";
          } else if (parseInt(tempAnzahlSpalten) < (parseInt(anzahlColumns) || 0)) {
            return "Reduzieren";
          } else return "Ändern"
        }
      }

      _isUebernehmenDisabled(tempAnzahlSpalten, anzahlColumns) {
        if (tempAnzahlSpalten && anzahlColumns && (parseInt(tempAnzahlSpalten) === parseInt(anzahlColumns))) {
          return true;
        } else {
          return false;
        }
      }

      _getText(){
        if (!!this.dataAndColumns){
          return "Neue Daten und Spaltenkonfiguration Speichern";
        } else if (!!this.spaltenConf){
          return "Spaltenkonfiguration Speichern";
        } else return "Weiter"
      }


    }

    class Member {
      constructor(memberKeys) {
        if (memberKeys) {
          this._createEmptyMember(memberKeys)
        }
      }

      _createEmptyMember(memberKeys) {
        memberKeys.forEach((paar) => {
          this[paar.left] = null;
        })
      }

    }

    window.customElements.define(ImportAllgemein.is, ImportAllgemein);
  </script>
</dom-module>